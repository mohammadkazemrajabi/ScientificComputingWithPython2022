# -*- coding: utf-8 -*-
"""04ex_numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fX1wg8U9v0xSQSpr_QwtUxvQDj9-rHLn
"""

import  numpy as np

"""ex1
total mean :
"""

m = np.arange(12).reshape((3,4))
print(m)

t=m.shape[0]*m.shape[1]
t

a=m.sum()
total_mean=a/t
print(f' total mean is {total_mean}')

"""calculate mean for each column:"""

m

#just show the columns in new form and use that to calclate the mean for each column
for i in range(m.shape[1]):
  print(m[:,i])

for i in range(m.shape[1]):
  print((m[:,i].sum())/m.shape[0])

"""calculate mean for each row:

"""

#just show the roes in new form and use that to calclate the mean for each row.

for i in range(m.shape[0]):
  print(m[i,:])

for i in range(m.shape[0]):
  print((m[i,:].sum())/m.shape[1])

"""ex 2:
Find the outer product of the following vectors:

"""

u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])

"""Using the function outer in numpy:

"""

outer_product=np.outer(u,v)
print(outer_product)

"""Using a nested for loop:"""

u.shape[0]

outerproduct=np.ones((u.shape[0],v.shape[0]))
for i in range(u.shape[0]):
  #print('dhh',u[i])
  for j in range(v.shape[0]):
    #print(v[j])
    outerproduct[i][j]=int(u[i]*v[j])
print(outerproduct)

"""Using numpy broadcasting operations:

"""

print(u.shape)

t=v.reshape((1,4))
t

U=u.reshape((4,1))
U

pp=t*U
print(pp)

"""ex 3
 Matrix masking


"""

matrix=np.random.uniform(0,3,(6,10))
my_mask=(matrix<0.3)
print(my_mask)
t=matrix[my_mask]=0
print('---------------------------')
print(matrix)

"""ex 4
Trigonometric functions
"""

import math
x=np.linspace(0,2*math.pi,100)
x.shape

"""Extract every 10th element using the slice notation"""

#with for loop
mylist=[next]
i=0
while i<x.shape[0]:
  mylist.append(x[i])
  i+=10
print(mylist)

"""Extract every 10th element using the slice notation

"""

secondlist=[]
secondlist=x[::10]
print(f'every 10th elemt in x {secondlist}')

"""Reverse the array using the slice notation

"""

reverse=x[::-1]
print(f'reverse of the array x :/n {reverse}')

"""Extract elements where the absolute difference between the sin and cos functions evaluated for that element is <0.1"""

mask2=x[abs(np.sin(x)-np.cos(x))<0.1]
print([abs(np.sin(x)-np.cos(x))<0.1])
print("\r\n")
print(x[abs(np.sin(x)-np.cos(x))<0.1])

"""ex 5
Create a matrix that shows the 10 by 10 multiplication table. 
"""

def mult_table(n):
    rng = np.arange(1, n+1)
    return rng * rng[:, None]
t=mult_table(10)
print(t)

trace=np.trace(t)
print(f'the trace of 10 by 10 multiplication table is : {trace}')

"""Extract the anti-diagonal matrix (this should be array([10, 18, 24, 28, 30, 30, 28, 24, 18, 10]))


"""

anti=np.flipud(t)
antidiagonal=np.diagonal(anti)
print(f'the trace of 10 by 10 multiplication table is : {antidiagonal}')

"""Extract the diagonal offset by 1 upwards (this should be array([ 2, 6, 12, 20, 30, 42, 56, 72, 90]))

"""

offset=np.diagonal(t,offset=1)
print(f'the trace of 10 by 10 multiplication table is : {offset}')

"""ex 6
Broadcasting
"""

#gird with nested for
grid=np.zeros((10,10))
positions=np.array([0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])
for i in range(grid.shape[0]):
  for j in range(grid.shape[1]):
    grid[i][j]=abs(positions[i]-positions[j])
print(grid)
print(grid.shape)

"""with boradcasting:"""

f1=np.array([[0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448]])
f2=np.array([[0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448]])
f3=f2.reshape((10,1))
print(f3)

final=abs(f3-f2)
print(final)

#conver mile to km
km_distance=final*1.60934
print(km_distance)
print(km_distance.shape)

"""ex 7
 Prime numbers sieve
 each True values in the prime array is correspondig to a prime number

consider the first prime number=2
by changing the p value in code you can set it to 1.
"""

def SieveOfEratosthenes(num):
#Constract a shape (N,) boolean array, which is the mask
    prime = np.array([True for i in range(num+1)])
    p = 2
    while (p * p <= num):
        if (prime[p] == True):
  
#Identify the multiples of each number starting from 2 and set accordingly the corresponding mask element
            for i in range(p * p, num+1, p):
                prime[i] = False
        p += 1
  
#Apply the mask to obtain an array of ordered prime numbers
    for p in range(2, num+1):
        if prime[p]:
            print(p)
    print(prime)
  
  

num = 100
SieveOfEratosthenes(num)

"""**Check the performances (with timeit); how does it scale with N?**
with increasing N the time also increases from 8 microsecont to 33 ms
"""

# Commented out IPython magic to ensure Python compatibility.
#previous function without pritn method for just compare the time
def new_SieveOfEratosthenes(num):
#Constract a shape (N,) boolean array, which is the mask
    prime = np.array([True for i in range(num+1)])
    p = 2
    while (p * p <= num):
        if (prime[p] == True):
  
#Identify the multiples of each number starting from 2 and set accordingly the corresponding mask element
            for i in range(p * p, num+1, p):
                prime[i] = False
        p += 1

#Apply the mask to obtain an array of ordered prime numbers
print('for N=10')
# %timeit [new_SieveOfEratosthenes(10)]
print('for N=100')

# %timeit [new_SieveOfEratosthenes(100)]
print('for N=10000')

# %timeit [new_SieveOfEratosthenes(10000)]

"""ex 8
Diffusion using random walk

Take 1000 walkers and let them walk for 200 steps
Use randint to create a 2D array of size  with values -1 or 1
"""

def my_func(waker,time):
  sum=[]
  distance=[]
  table=np.zeros((waker,time))
  for i in range(table.shape[0]):
    t=np.random.randint(-1,1,time)
    #create mask to convert 0 to 1 because we want 2 values(-1,1)
    t[t==0]=1
    for j in range(t.shape[0]):
      table[i][j]=t[j]
  print(table)
  for i in range(table.shape[0]):
    sum.append(table[i].sum())
  #print('he walking distances for each walker')
  return(sum)

my_func(10,5)

"""Take the square of the previously-obtained array (element-wise)

"""

sqrt_list=(np.array(my_func(10,5))**2)
print(sqrt_list)

#second approach
r=np.square(my_func(10,5))
print(r)

"""ompute the mean of the squared distances at each step (i.e. the mean along the columns)"""

def mean(waker,time):
  mean=[]
  table=np.zeros((waker,time))
  for i in range(table.shape[0]):
    t=np.random.randint(-1,1,time)
    #create mask to convert 0 to 1 because we want 2 values(-1,1)
    t[t==0]=1
    for j in range(t.shape[0]):
      table[i][j]=t[j]
  #print(table)
  for i in range(table.shape[1]):
    #print(table[:,i])
    mean.append(table[:,i].sum())
  return np.array(mean)/table.shape[0]

mean(10,3)

m=np.array([[1,2,3],[5,6,7],[8,9,10]])
m

r=np.mean(mean(10,5),axis=0)
print(r)